<html>
	<head>
		<title>WebGl SDF Font Renderer</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<style>
			* {
				padding: 0;
				margin: 0;
			}
			canvas {
				width: 100vw;
				height: 100vh;
			}
		</style>
		
		<script type="text/javascript" src="glMatrix.js"></script>
		<script type="text/javascript" src="font/SignedDistanceFont.js"></script>

		<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
			  precision mediump float;

			  in vec2 v_uv;

			  uniform sampler2D uMainTex;

			  out vec4 fragmentColor;

			  const vec4 fontColor = vec4(1.0, 0.0, 0.0, 1.0);

			  float aastep(float threshold, float value) {
				#ifdef GL_OES_standard_derivatives
				  float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
				  return smoothstep(threshold-afwidth, threshold+afwidth, value);
				#else
				  return step(threshold, value);
				#endif
			  }

			  void main(void) {
				vec4 texColor = texture(uMainTex, v_uv);
				fragmentColor = vec4(fontColor.rgb, texColor.a);
				if (texColor.a < 0.5) {
				  discard;
				}
			  }
		</script>

		<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
			  
			in vec3 a_position;
			in vec2 a_uv;
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform float tick;

			out vec2 v_uv;
				
			const float pi = 3.14159265;

			void main() {
				v_uv = a_uv;
			
				vec3 displacedPosition = a_position;

				float speed = 0.10;

				float magnitude = (sin((displacedPosition.y + displacedPosition.x + tick * pi / ((28.0) * speed))) * 0.15 + 0.15) * 0.30 * 20.0;
				float d0 = sin(tick * pi / (112.0 * speed)) * 3.0 - 1.5;
				float d1 = sin(tick * pi / (142.0 * speed)) * 3.0 - 1.5;
				float d2 = sin(tick * pi / (132.0 * speed)) * 3.0 - 1.5;
				float d3 = sin(tick * pi / (122.0 * speed)) * 3.0 - 1.5;
				displacedPosition.x += sin((tick * pi / (18.0 * speed)) + (-displacedPosition.x + d0)*1.6 + (displacedPosition.z + d1)*1.6) * magnitude;
				displacedPosition.z += sin((tick * pi / (17.0 * speed)) + (displacedPosition.z + d2)*1.6 + (-displacedPosition.x + d3)*1.6) * magnitude;
				displacedPosition.y += sin((tick * pi / (11.0 * speed)) + (displacedPosition.z + d2) + (displacedPosition.x + d3)) * (magnitude/2.0);
				gl_Position = uPMatrix * uMVMatrix * vec4(displacedPosition, 1.0);
			}
		</script>


		<script type="text/javascript">

			var gl;

			function initGL(canvas) {
				try {
					gl = canvas.getContext("webgl2", {alpha: true});
				} catch (e) {
				}
				if (!gl) {
					alert("Could not initialise WebGL, sorry :-(");
				}
			}
			
			function resize(canvas) {
			  // Lookup the size the browser is displaying the canvas.
			  var displayWidth  = canvas.clientWidth;
			  var displayHeight = canvas.clientHeight;

			  // Check if the canvas is not the same size.
			  if (canvas.width  != displayWidth ||
				  canvas.height != displayHeight) {

				// Make the canvas the same size
				canvas.width  = displayWidth;
				canvas.height = displayHeight;
			  }
			}


			function getShader(gl, id) {
				var shaderScript = document.getElementById(id);
				if (!shaderScript) {
					return null;
				}

				var str = "";
				var k = shaderScript.firstChild;
				while (k) {
					if (k.nodeType == 3) {
						str += k.textContent;
					}
					k = k.nextSibling;
				}

				var shader;
				if (shaderScript.type == "x-shader/x-fragment") {
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} else if (shaderScript.type == "x-shader/x-vertex") {
					shader = gl.createShader(gl.VERTEX_SHADER);
				} else {
					return null;
				}

				gl.shaderSource(shader, str);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					alert(gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}


			var shaderProgram;

			function initShaders() {
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					alert("Could not initialise shaders");
				}

				gl.useProgram(shaderProgram);

				shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "a_position");
				gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

				shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "a_uv");
				gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

				shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
				shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
				shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
				shaderProgram.tickUniform = gl.getUniformLocation(shaderProgram, "tick");
			}

			function handleLoadedTexture(texture) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				gl.generateMipmap(gl.TEXTURE_2D);

				gl.bindTexture(gl.TEXTURE_2D, null);
			}

			var crateTexture;
			function initTexture() {
				crateTexture = gl.createTexture();
				crateTexture.image = new Image();
				crateTexture.image.onload = function () {
					handleLoadedTexture(crateTexture)
				}

				crateTexture.image.src = "font/arial/arial.png";
			}

			var mvMatrix = mat4.create();
			var mvMatrixStack = [];
			var pMatrix = mat4.create();

			function mvPushMatrix() {
				var copy = mat4.create();
				mat4.set(mvMatrix, copy);
				mvMatrixStack.push(copy);
			}

			function mvPopMatrix() {
				if (mvMatrixStack.length == 0) {
					throw "Invalid popMatrix!";
				}
				mvMatrix = mvMatrixStack.pop();
			}


			function setMatrixUniforms() {
				gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
			}


			function degToRad(degrees) {
				return degrees * Math.PI / 180;
			}



			var xRot = 0;
			var xSpeed = 3;

			var yRot = 0;
			var ySpeed = -3;

			var z = -5.0;

			var cubeVertexPositionBuffer;
			var cubeVertexTextureCoordBuffer;
			var cubeVertexIndexBuffer;

			function initBuffers() {	
				readTextFile("font/arial/arial.json", function(fontInfo) {
					var font = new SignedDistanceFont([
						"WebGL", 
						"SDF Font Rendering",
						"Test"
					], {
						fontInfo: JSON.parse(fontInfo),
						alignment: "center",
						scale: 1
					});
				  
					cubeVertexPositionBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(font.mesh.vertices), gl.STATIC_DRAW);
					cubeVertexPositionBuffer.itemSize = 3;
					cubeVertexPositionBuffer.numItems = font.mesh.vertices.length;

					cubeVertexTextureCoordBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(font.mesh.textureCoords), gl.STATIC_DRAW);
					cubeVertexTextureCoordBuffer.itemSize = 2;
					cubeVertexTextureCoordBuffer.numItems = font.mesh.textureCoords.length;

					cubeVertexIndexBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(font.mesh.indices), gl.STATIC_DRAW);
					cubeVertexIndexBuffer.itemSize = 1;
					cubeVertexIndexBuffer.numItems = font.mesh.indices.length;
				});
			}

			function readTextFile(file, callback) {
				var rawFile = new XMLHttpRequest();
				rawFile.overrideMimeType("application/json");
				rawFile.open("GET", file, true);
				rawFile.onreadystatechange = function() {
					if (rawFile.readyState === 4 && rawFile.status == "200") {
						callback(rawFile.responseText);
					}
				}
				rawFile.send(null);
			}

			function drawScene() {
				resize(canvas);
				gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				mat4.perspective(45, gl.drawingBufferWidth / gl.drawingBufferHeight, 0.1, 100000.0, pMatrix);

				mat4.identity(mvMatrix);

				mat4.translate(mvMatrix, [0.0, 0.0, -700.0]);

				mat4.rotate(mvMatrix, degToRad(xRot), [1, 0, 0]);
				mat4.rotate(mvMatrix, degToRad(yRot), [0, 1, 0]);

				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
				gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, crateTexture);
				gl.uniform1i(shaderProgram.samplerUniform, 0);
				
				gl.uniform1f(shaderProgram.tickUniform, performance.now() / 500);
				
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
				gl.enable(gl.BLEND);

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			}


			var lastTime = 0;

			function animate() {
				var timeNow = new Date().getTime();
				if (lastTime != 0) {
					var elapsed = timeNow - lastTime;

					xRot += (xSpeed * elapsed) / 1000.0;
					yRot += (ySpeed * elapsed) / 1000.0;
				}
				lastTime = timeNow;
			}


			function tick() {
				requestAnimationFrame(tick);
				
				if(cubeVertexPositionBuffer != undefined) {
					drawScene();
				}
				animate();
			}


			var canvas;
			function webGLStart() {
				canvas = document.getElementById("lesson07-canvas");
				initGL(canvas);
				initShaders();
				initBuffers();
				initTexture();

				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				tick();
			}

		</script>
	</head>
	<body onload="webGLStart();">
		<canvas id="lesson07-canvas" style="border: none;" width="500" height="500"></canvas>
	</body>
</html>
